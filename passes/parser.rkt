#lang racket

(require "lexer.rkt")
(require parser-tools/lex
         parser-tools/yacc)

(require "../utils.rkt")

(require "../datatypes.rkt")
(#%require "../datatypes.rkt")

(define python-parser
  (parser
   (start Program)
   (end EOF)
   ;    (error (lambda (x y z) (display-lines (list x y z))))
   (error void)
   (tokens
    LITERALS KWS OPS LOOP_KWS BOOL_KWS BOOL_OPS
    COND_KWS COND_OPS ARITH_OPS INDEX_OPS END
    )
   (grammar
    (Program ((Statements) $1))
    (Statements ((Statement SEMICOLON) (list $1))
                ((Statements Statement SEMICOLON) (append $1 (list $2)))
                )
    (Statement ((Compound_stmt) $1)
               ((Simple_stmt) $1)
               )
    (Simple_stmt ((Assignment) $1)
                 ((Global_stmt) $1)
                 ((Return_stmt) $1)
                 ((PASS) (pass))
                 ((BREAK) (break))
                 ((CONTINUE) (continue))
                 ((PRINT PAR) (print_stmt (empty-expr)))
                 ((PRINT LPAR Arguments RPAR) (print_stmt $3))
                 )
    (Compound_stmt ((Function_def) $1)
                   ((If_stmt) $1)
                   ((For_stmt) $1)
                   )
    (Assignment ((ID ASSIGN Expression) (assign $1 $3)))
    (Return_stmt ((RETURN) (return_void))
                 ((RETURN Expression) (return $2))
                 )
    (Global_stmt ((GLOBAL ID) (global $2)))
    (Function_def ((DEF ID LPAR Params RPAR COLON Statements) (func $2 $4 $7))
                  ((DEF ID PAR COLON Statements) (func $2 (empty-param) $5))
                  )
    (Params ((Param_with_default) (func_params $1 (empty-param)))
            ((Params COMMA Param_with_default) (func_params $3 $1))
            )
    (Param_with_default ((ID ASSIGN Expression) (with_default $1 $3)))
    (If_stmt ((IF Expression COLON Statements Else_block) (if_stmt $2 $4 $5)))
    (Else_block ((ELSE COLON Statements) $3))
    (For_stmt ((FOR ID IN Expression COLON Statements) (for_stmt $2 $4 $6)))
    (Expression ((Disjunction) $1))
    (Disjunction ((Conjunction) $1)
                 ((Disjunction OR Conjunction) (binary_op (lambda (x y) (or x y)) $1 $3))
                 )
    (Conjunction ((Inversion) $1)
                 ((Conjunction AND Inversion) (binary_op (lambda (x y) (or x y)) $1 $3))
                 )
    (Inversion ((NOT Inversion) (unary_op not $2))
               ((Comparison) $1)
               )
    (Comparison ((Eq_Sum) $1)
                ((Lt_Sum) $1)
                ((Gt_Sum) $1)
                ((Sum) $1)
                )
    (Eq_Sum ((Sum ISEQ Sum) (binary_op equal? $1 $3)))
    (Lt_Sum ((Sum LT Sum) (binary_op < $1 $3)))
    (Gt_Sum ((Sum BT Sum) (binary_op > $1 $3)))
    (Sum ((Sum PLUS Term) (binary_op (lambda (x y) (if (number? x) (+ x y) (append x y))) $1 $3))
         ((Sum MINUS Term) (binary_op - $1 $3))
         ((Term) $1)
         )
    (Term ((Term MULTI Factor) (binary_op * $1 $3))
          ((Term DIV Factor) (binary_op / $1 $3))
          ((Factor) $1)
          )
    (Factor ((PLUS Power) (unary_op + $2))
            ((MINUS Power) (unary_op - $2))
            ((Power) $1)
            )
    (Power ((Atom POW Factor) (binary_op expt $1 $3))
           ((Primary) $1)
           )
    (Primary ((Atom) $1)
             ((Primary LBRACK Expression RBRACK) (list_ref $1 $3))
             ((Primary PAR) (function_call $1 (empty-expr)))
             ((Primary LPAR Arguments RPAR) (function_call $1 $3))
             )
    (Arguments ((Expression) (expressions $1 (empty-expr)))
               ((Arguments COMMA Expression) (expressions $3 $1))
               )
    (Atom ((ID) (ref $1))
          ((TRUE) (atomic_bool_exp true))
          ((FALSE) (atomic_bool_exp false))
          ((NONE) (atomic_null_exp))
          ((NUMBER) (atomic_num_exp $1))
          ((List) $1)
          )
    (List ((LBRACK Expressions RBRACK) (atomic_list_exp $2))
          ((BRACK) (atomic_list_exp (empty-expr)))
          )
    (Expressions ((Expressions COMMA Expression) (expressions $3 $1))
                 ((Expression) (expressions $1 (empty-expr)))
                 ))
   ;    (debug "x.txt")
   ))

(define (parse-scan prog-string)
  ;   (display-return
  (python-parser (lex-this prog-string))
  ;    )
  )

(provide (all-defined-out))